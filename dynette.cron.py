#!/usr/bin/python3

import os
import sys
import psycopg2
from urllib import urlopen
import json

with open('config.json') as config_file:
    config = json.load(config_file)

conf_file = '/etc/bind/named.conf.local'    # Include this filename in '/etc/bind/named.conf'
zone_dir  = '/var/lib/bind/'                # Do not forget the trailing '/'
database = config_file["dabase_url"]
base_url  = config_file["base_url"]
ns0       = config_file["ns0"]
ns1       = config_file["ns1"]
rname     = config_file["rname"]            # Responsible person (https://tools.ietf.org/html/rfc1035#section-3.3.13)
master_key = config_file["master_key"]
dyndns_domains = config_file['dyndns_domains']
allowed_operations = config_files["allowed_operations"]

with psycopg2.connect(database) as postgresql_connection:
    with postgresql_connection.cursor() as psql:
        # look in the job queue if we have tasks to handle
        need_rewrite = False
        need_bind9_cache_flush = False

        # DataMapper convert table names to lower cases and add a "s" at the
        # end
        # consume all available tasks at once to merge them and avoir doing
        # useless jobs
        psql.execute("SELECT task FROM jobqueues ORDER BY id ASC;")

        for task in psql.fetchall():
            task = task[0]
            if task == "conf_rewrite":
                need_rewrite = True
            elif task == "bind9_cache_flush":
                need_bind9_cache_flush = True

        if not need_rewrite and not need_bind9_cache_flush:
            sys.exit(0)

        # we have consume all the jobs, flush it
        # because we are in a SQL transaction we won't have situation where a
        # job could be added just after we read them all
        psql.execute("DELETE FROM jobqueues;")

        # Init zone for dyndns domains that don't already exists
        for domain in dyndns_domains:
            if os.path.exists(zone_dir + domain +'.db'):
                continue

            db_lines = f"""
$ORIGIN .
$TTL 10 ; 10 seconds
{domain}.   IN SOA  {ns0}. {rname}. (
          18         ; serial
          10800      ; refresh (3 hours)
          3600       ; retry (1 hour)
          604800     ; expire (1 week)
          10         ; minimum (10 seconds)

$TTL 3600       ; 1 hour
          NS      {ns0}.
          NS      {ns1}.

$ORIGIN {domain}.
"""
            with open(zone_dir + domain +'.db', 'w') as zone:
                zone.write(db_lines)

        # Update /etc/bind/named.conf.local
        # that provide permissions for all regirested subdomains on allowed zone file elements
        # and registers the key for bind9, later used to authenticate nsupdate from the clients
        lines = ['// Generated by Dynette CRON']
        lines.append(f"""
key dynette. {
       algorithm hmac-md5;
       secret "{master_key}";
};
""")
        for domain in dyndns_domains:
            lines.append(f"""
zone "{domain}" {
   type master;
   file {zone_dir}{domain}.db;
   update-policy {
       grant dynette. wildcard *.{domain}. ANY;""")

            # Get registered sub-domains
            registered_subdomains = json.loads(str(urlopen(base_url +'/all/'+ domain).read()))
            for entry in registered_subdomains:
                for subd, types in allowed_operations.items():
                    if subd == '.':
                        subd = ''
                    all_types = ' '.join(types)
                    lines.append(f"       grant {entry['subdomain']}. name {subd}{entry['subdomain']}. {all_types};")

            lines.append(f"""
   };
};""")

            for entry in registered_subdomains:
                lines.append(f"""
key {entry['subdomain']}. {
    algorithm {entry['key_algo']};
    secret {entry['public_key']};
};
"""

        # update bind9 zone
        if need_rewrite:
            # Backup old Bind configuration file.
            os.system('cp '+ conf_file +' '+ conf_file +'.back')

            # Write Bind configuration file.
            with open(conf_file, 'w') as zone:
                zone.write('\n'.join(lines) + '\n')

            # Restore ownership
            os.system('chown -R bind:bind '+ zone_dir +' '+ conf_file)

            # Reload Bind
            if os.system('/usr/sbin/rndc reload') != 0:
                os.system('cp '+ conf_file +' '+ conf_file +'.bad')
                os.system('cp '+ conf_file +'.back '+ conf_file)
                os.system('/usr/sbin/rndc reload')
                print("An error occured ! Please check daemon.log and your conf.bad")
                sys.exit(1)

        # flush bind9 cache (mostly because we got a hmac-sha512 key migration
        if need_bind9_cache_flush:
            os.system('/usr/sbin/rndc flush')
            os.system('/usr/sbin/rndc reload')
